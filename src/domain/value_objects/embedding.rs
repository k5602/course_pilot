//! Embedding value object for semantic vectors.

/// A semantic embedding vector generated by the ML engine.
/// Typically 384 dimensions for bge-small-en-v1.5.
#[derive(Debug, Clone)]
pub struct Embedding {
    vector: Vec<f32>,
}

impl Embedding {
    /// Creates a new embedding from a vector.
    pub fn new(vector: Vec<f32>) -> Self {
        Self { vector }
    }

    /// Returns the embedding vector.
    pub fn vector(&self) -> &[f32] {
        &self.vector
    }

    /// Returns the dimensionality of the embedding.
    pub fn dimensions(&self) -> usize {
        self.vector.len()
    }

    /// Calculates cosine similarity with another embedding.
    /// Returns a value between -1.0 and 1.0, where 1.0 means identical.
    pub fn cosine_similarity(&self, other: &Embedding) -> f32 {
        if self.vector.len() != other.vector.len() {
            return 0.0;
        }

        let dot_product: f32 =
            self.vector.iter().zip(other.vector.iter()).map(|(a, b)| a * b).sum();

        let magnitude_self: f32 = self.vector.iter().map(|x| x * x).sum::<f32>().sqrt();
        let magnitude_other: f32 = other.vector.iter().map(|x| x * x).sum::<f32>().sqrt();

        if magnitude_self == 0.0 || magnitude_other == 0.0 {
            return 0.0;
        }

        dot_product / (magnitude_self * magnitude_other)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cosine_similarity_identical() {
        let e1 = Embedding::new(vec![1.0, 0.0, 0.0]);
        let e2 = Embedding::new(vec![1.0, 0.0, 0.0]);
        assert!((e1.cosine_similarity(&e2) - 1.0).abs() < 0.001);
    }

    #[test]
    fn test_cosine_similarity_orthogonal() {
        let e1 = Embedding::new(vec![1.0, 0.0, 0.0]);
        let e2 = Embedding::new(vec![0.0, 1.0, 0.0]);
        assert!(e1.cosine_similarity(&e2).abs() < 0.001);
    }

    #[test]
    fn test_cosine_similarity_opposite() {
        let e1 = Embedding::new(vec![1.0, 0.0, 0.0]);
        let e2 = Embedding::new(vec![-1.0, 0.0, 0.0]);
        assert!((e1.cosine_similarity(&e2) + 1.0).abs() < 0.001);
    }
}
